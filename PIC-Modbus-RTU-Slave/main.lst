CCS PCH C Compiler, Version 5.101, 61971               20-Kas-22 18:16

               Filename:   G:\Unity\ModBus-Test\modbus_test\main.lst

               ROM used:   2850 bytes (9%)
                           Largest free fragment is 29914
               RAM used:   109 (7%) at main() level
                           129 (8%) worst case
               Stack used: 8 locations (5 in main + 3 for interrupts)
               Stack size: 31

*
0000:  GOTO   0A26
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.0
0056:  GOTO   0060
005A:  BTFSC  F9E.0
005C:  GOTO   02EE
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0392
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... // TTL to USB : https://www.robolinkmarket.com/usb-rs485-donusturucu-modul
.................... // RS485 to TTL : https://www.robolinkmarket.com/rs485-ttl-seri-donusturucu-karti
.................... // Source: https://github.com/furkanbakkal
.................... 
.................... //DE and RE pins shorted ->D2
.................... //DI -> TX
.................... //RO -> RX
.................... 
.................... //A->A  
.................... //B->B
.................... 
.................... /*Supported functions:
.................... 
.................... 3 : Read holding register
.................... 6 : Write single register
.................... 15: Wrtie multiple registers
.................... */
.................... 
.................... /* LCD Pins
.................... 
.................... LCD_DB4   PIN_B4
.................... LCD_DB5   PIN_B5
.................... LCD_DB6   PIN_B6
.................... LCD_DB7   PIN_B7
.................... 
.................... LCD_RS    PIN_B3
.................... LCD_RW    PIN_B2
.................... LCD_E     PIN_B1
.................... */
.................... 
.................... #include <main.h>
.................... #include <18F4520.h>
.................... //////////// Standard Header file for the PIC18F4520 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
*
02F0:  BCF    F9E.0
02F2:  GOTO   006C
.................... #device PIC18F4520
*
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 00,C1
00CC:  DATA 81,40
00CE:  DATA 01,C0
00D0:  DATA 80,41
00D2:  DATA 01,C0
00D4:  DATA 80,41
00D6:  DATA 00,C1
00D8:  DATA 81,40
00DA:  DATA 01,C0
00DC:  DATA 80,41
00DE:  DATA 00,C1
00E0:  DATA 81,40
00E2:  DATA 00,C1
00E4:  DATA 81,40
00E6:  DATA 01,C0
00E8:  DATA 80,41
00EA:  DATA 01,C0
00EC:  DATA 80,41
00EE:  DATA 00,C1
00F0:  DATA 81,40
00F2:  DATA 00,C1
00F4:  DATA 81,40
00F6:  DATA 01,C0
00F8:  DATA 80,41
00FA:  DATA 00,C1
00FC:  DATA 81,40
00FE:  DATA 01,C0
0100:  DATA 80,41
0102:  DATA 01,C0
0104:  DATA 80,41
0106:  DATA 00,C1
0108:  DATA 81,40
010A:  DATA 01,C0
010C:  DATA 80,41
010E:  DATA 00,C1
0110:  DATA 81,40
0112:  DATA 00,C1
0114:  DATA 81,40
0116:  DATA 01,C0
0118:  DATA 80,41
011A:  DATA 00,C1
011C:  DATA 81,40
011E:  DATA 01,C0
0120:  DATA 80,41
0122:  DATA 01,C0
0124:  DATA 80,41
0126:  DATA 00,C1
0128:  DATA 81,40
012A:  DATA 00,C1
012C:  DATA 81,40
012E:  DATA 01,C0
0130:  DATA 80,41
0132:  DATA 01,C0
0134:  DATA 80,41
0136:  DATA 00,C1
0138:  DATA 81,40
013A:  DATA 01,C0
013C:  DATA 80,41
013E:  DATA 00,C1
0140:  DATA 81,40
0142:  DATA 00,C1
0144:  DATA 81,40
0146:  DATA 01,C0
0148:  DATA 80,41
014A:  DATA 01,C0
014C:  DATA 80,41
014E:  DATA 00,C1
0150:  DATA 81,40
0152:  DATA 00,C1
0154:  DATA 81,40
0156:  DATA 01,C0
0158:  DATA 80,41
015A:  DATA 00,C1
015C:  DATA 81,40
015E:  DATA 01,C0
0160:  DATA 80,41
0162:  DATA 01,C0
0164:  DATA 80,41
0166:  DATA 00,C1
0168:  DATA 81,40
016A:  DATA 00,C1
016C:  DATA 81,40
016E:  DATA 01,C0
0170:  DATA 80,41
0172:  DATA 01,C0
0174:  DATA 80,41
0176:  DATA 00,C1
0178:  DATA 81,40
017A:  DATA 01,C0
017C:  DATA 80,41
017E:  DATA 00,C1
0180:  DATA 81,40
0182:  DATA 00,C1
0184:  DATA 81,40
0186:  DATA 01,C0
0188:  DATA 80,41
018A:  DATA 00,C1
018C:  DATA 81,40
018E:  DATA 01,C0
0190:  DATA 80,41
0192:  DATA 01,C0
0194:  DATA 80,41
0196:  DATA 00,C1
0198:  DATA 81,40
019A:  DATA 01,C0
019C:  DATA 80,41
019E:  DATA 00,C1
01A0:  DATA 81,40
01A2:  DATA 00,C1
01A4:  DATA 81,40
01A6:  DATA 01,C0
01A8:  DATA 80,41
01AA:  DATA 01,C0
01AC:  DATA 80,41
01AE:  DATA 00,C1
01B0:  DATA 81,40
01B2:  DATA 00,C1
01B4:  DATA 81,40
01B6:  DATA 01,C0
01B8:  DATA 80,41
01BA:  DATA 00,C1
01BC:  DATA 81,40
01BE:  DATA 01,C0
01C0:  DATA 80,41
01C2:  DATA 01,C0
01C4:  DATA 80,41
01C6:  DATA 00,C1
01C8:  DATA 81,40
01CA:  CLRF   FF7
01CC:  ADDLW  DA
01CE:  MOVWF  FF6
01D0:  MOVLW  01
01D2:  ADDWFC FF7,F
01D4:  TBLRD*+
01D6:  MOVF   FF5,W
01D8:  RETURN 0
01DA:  DATA 00,C0
01DC:  DATA C1,01
01DE:  DATA C3,03
01E0:  DATA 02,C2
01E2:  DATA C6,06
01E4:  DATA 07,C7
01E6:  DATA 05,C5
01E8:  DATA C4,04
01EA:  DATA CC,0C
01EC:  DATA 0D,CD
01EE:  DATA 0F,CF
01F0:  DATA CE,0E
01F2:  DATA 0A,CA
01F4:  DATA CB,0B
01F6:  DATA C9,09
01F8:  DATA 08,C8
01FA:  DATA D8,18
01FC:  DATA 19,D9
01FE:  DATA 1B,DB
0200:  DATA DA,1A
0202:  DATA 1E,DE
0204:  DATA DF,1F
0206:  DATA DD,1D
0208:  DATA 1C,DC
020A:  DATA 14,D4
020C:  DATA D5,15
020E:  DATA D7,17
0210:  DATA 16,D6
0212:  DATA D2,12
0214:  DATA 13,D3
0216:  DATA 11,D1
0218:  DATA D0,10
021A:  DATA F0,30
021C:  DATA 31,F1
021E:  DATA 33,F3
0220:  DATA F2,32
0222:  DATA 36,F6
0224:  DATA F7,37
0226:  DATA F5,35
0228:  DATA 34,F4
022A:  DATA 3C,FC
022C:  DATA FD,3D
022E:  DATA FF,3F
0230:  DATA 3E,FE
0232:  DATA FA,3A
0234:  DATA 3B,FB
0236:  DATA 39,F9
0238:  DATA F8,38
023A:  DATA 28,E8
023C:  DATA E9,29
023E:  DATA EB,2B
0240:  DATA 2A,EA
0242:  DATA EE,2E
0244:  DATA 2F,EF
0246:  DATA 2D,ED
0248:  DATA EC,2C
024A:  DATA E4,24
024C:  DATA 25,E5
024E:  DATA 27,E7
0250:  DATA E6,26
0252:  DATA 22,E2
0254:  DATA E3,23
0256:  DATA E1,21
0258:  DATA 20,E0
025A:  DATA A0,60
025C:  DATA 61,A1
025E:  DATA 63,A3
0260:  DATA A2,62
0262:  DATA 66,A6
0264:  DATA A7,67
0266:  DATA A5,65
0268:  DATA 64,A4
026A:  DATA 6C,AC
026C:  DATA AD,6D
026E:  DATA AF,6F
0270:  DATA 6E,AE
0272:  DATA AA,6A
0274:  DATA 6B,AB
0276:  DATA 69,A9
0278:  DATA A8,68
027A:  DATA 78,B8
027C:  DATA B9,79
027E:  DATA BB,7B
0280:  DATA 7A,BA
0282:  DATA BE,7E
0284:  DATA 7F,BF
0286:  DATA 7D,BD
0288:  DATA BC,7C
028A:  DATA B4,74
028C:  DATA 75,B5
028E:  DATA 77,B7
0290:  DATA B6,76
0292:  DATA 72,B2
0294:  DATA B3,73
0296:  DATA B1,71
0298:  DATA 70,B0
029A:  DATA 50,90
029C:  DATA 91,51
029E:  DATA 93,53
02A0:  DATA 52,92
02A2:  DATA 96,56
02A4:  DATA 57,97
02A6:  DATA 55,95
02A8:  DATA 94,54
02AA:  DATA 9C,5C
02AC:  DATA 5D,9D
02AE:  DATA 5F,9F
02B0:  DATA 9E,5E
02B2:  DATA 5A,9A
02B4:  DATA 9B,5B
02B6:  DATA 99,59
02B8:  DATA 58,98
02BA:  DATA 88,48
02BC:  DATA 49,89
02BE:  DATA 4B,8B
02C0:  DATA 8A,4A
02C2:  DATA 4E,8E
02C4:  DATA 8F,4F
02C6:  DATA 8D,4D
02C8:  DATA 4C,8C
02CA:  DATA 44,84
02CC:  DATA 85,45
02CE:  DATA 87,47
02D0:  DATA 46,86
02D2:  DATA 82,42
02D4:  DATA 43,83
02D6:  DATA 41,81
02D8:  DATA 80,40
02DA:  CLRF   FF7
02DC:  ADDLW  EA
02DE:  MOVWF  FF6
02E0:  MOVLW  02
02E2:  ADDWFC FF7,F
02E4:  TBLRD*+
02E6:  MOVF   FF5,W
02E8:  RETURN 0
02EA:  DATA 28,0C
02EC:  DATA 01,06
02EE:  INCF   5F,F
*
03F2:  DATA 53,79
03F4:  DATA 73,74
03F6:  DATA 65,6D
03F8:  DATA 20,53
03FA:  DATA 74,61
03FC:  DATA 72,74
03FE:  DATA 65,64
0400:  DATA 21,00
*
0606:  TBLRD*+
0608:  MOVF   FF5,F
060A:  BZ    0624
060C:  MOVFF  FF6,6D
0610:  MOVFF  FF7,6E
0614:  MOVFF  FF5,6F
0618:  RCALL  05BE
061A:  MOVFF  6D,FF6
061E:  MOVFF  6E,FF7
0622:  BRA    0606
0624:  GOTO   0A9E (RETURN)
0628:  BTFSC  6E.7
062A:  BRA    064A
062C:  MOVLW  0F
062E:  MOVWF  00
0630:  SWAPF  6D,W
0632:  ANDWF  00,F
0634:  MOVLW  0A
0636:  SUBWF  00,W
0638:  BC    0640
063A:  MOVLW  30
063C:  ADDWF  00,F
063E:  BRA    0644
0640:  MOVF   6E,W
0642:  ADDWF  00,F
0644:  MOVFF  00,6F
0648:  RCALL  05BE
064A:  MOVLW  0F
064C:  ANDWF  6D,F
064E:  MOVLW  0A
0650:  SUBWF  6D,W
0652:  BC    0658
0654:  MOVLW  30
0656:  BRA    065C
0658:  BCF    6E.7
065A:  MOVF   6E,W
065C:  ADDWF  6D,F
065E:  MOVFF  6D,6F
0662:  RCALL  05BE
0664:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... 
.................... #use delay(internal=8MHz)
*
042C:  CLRF   FEA
042E:  MOVLW  70
0430:  MOVWF  FE9
0432:  MOVF   FEF,W
0434:  BZ    0450
0436:  MOVLW  02
0438:  MOVWF  01
043A:  CLRF   00
043C:  DECFSZ 00,F
043E:  BRA    043C
0440:  DECFSZ 01,F
0442:  BRA    043A
0444:  MOVLW  97
0446:  MOVWF  00
0448:  DECFSZ 00,F
044A:  BRA    0448
044C:  DECFSZ FEF,F
044E:  BRA    0436
0450:  RETURN 0
.................... 
.................... 
.................... 
.................... #define MODBUS_BUS SERIAL
.................... #define MODBUS_TYPE MODBUS_TYPE_SLAVE //PIC is Slave, PC is Master
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU //Modbus RTU
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA //Default TX RX pins 
.................... #define MODBUS_SERIAL_RX_ENABLE PIN_D2 //Enable pin for response
.................... #define MODBUS_OUR_ADDRESS 10
.................... 
.................... #define MODBUS_SERIAL_BAUD 9600 //baudrate
.................... #define MODBUS_ADDRESS 0x05 //slave id (default:5)
.................... 
.................... #include "modbus.c" 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                     modbus.c                                     ////
.................... ////                                                                                  ////
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... ////  How to Use:                                                                     ////
.................... ////                                                                                  ////
.................... ////  Include just this file, modbus.c, in your main program. Before including this   ////
.................... ////  file define the constants below for your needs.                                 ////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   ////
.................... ////                                                                                  ////
.................... //// SERIAL DEFINES:                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   ////
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               ////
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... //// TCP/IP DEFINES:                                                                  ////
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          ////
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      ////
.................... ////                                   (default 502)                                  ////
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   ////
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) ////
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     ////
.................... ////                                   from server before setting TIMEOUT exception   ////
.................... ////                                   (default 5)                                    ////
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             ////
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 ////
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 ////
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////  May 8, 2009       Made PCD Compatible                                           ////
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   ////
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  ////
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   ////
.................... ////                    on PIC.                                                       ////
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code ////
.................... ////                    was seperated into header and c files for the Physical and    ////
.................... ////                    Application layers, and RTU code and ASCII code.              ////
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 ////
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       ////
.................... ////                    modes.                                                        ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #include <modbus.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                     modbus.h                                     ////
.................... ////                                                                                  ////
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// DEFINES:                                                                         ////
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   ////
.................... ////                                                                                  ////
.................... //// SERIAL DEFINES:                                                                  ////
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           ////
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              ////
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   ////
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               ////
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        ////
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        ////
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      ////
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     ////
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           ////
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       ////
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        ////
.................... ////                                                                                  ////
.................... //// TCP/IP DEFINES:                                                                  ////
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          ////
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      ////
.................... ////                                   (default 502)                                  ////
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   ////
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) ////
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     ////
.................... ////                                   from server before setting TIMEOUT exception   ////
.................... ////                                   (default 5)                                    ////
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             ////
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 ////
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 ////
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////  May 8, 2009       Made PCD Compatible                                           ////
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   ////
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  ////
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   ////
.................... ////                    on PIC.                                                       ////
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code ////
.................... ////                    was seperated into header and c files for the Physical and    ////
.................... ////                    Application layers, and RTU code and ASCII code.              ////
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 ////
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       ////
.................... ////                    modes.                                                        ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2010 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_H
.................... #define MODBUS_H
.................... 
.................... /*Some defines so we can use identifiers to set things up*/
.................... #define MODBUS_PROTOCOL_SERIAL 0
.................... #define MODBUS_PROTOCOL_TCPIP  100
.................... #define MODBUS_TYPE_MASTER 99999
.................... #define MODBUS_TYPE_SLAVE  88888
.................... #define MODBUS_TYPE_CLIENT 20
.................... #define MODBUS_TYPE_SERVER 21
.................... #define MODBUS_INT_RDA     77777
.................... #define MODBUS_INT_RDA2    66666
.................... #define MODBUS_INT_RDA3    44444
.................... #define MODBUS_INT_RDA4    33333
.................... #define MODBUS_INT_RDA5    22222
.................... #define MODBUS_INT_RDA6    11111
.................... #define MODBUS_INT_EXT     55555
.................... #define MODBUS_RTU         1
.................... #define MODBUS_ASCII       2
.................... #define MODBUS_TIMER_NOISR 13
.................... #define MODBUS_TIMER_ISR   12
.................... #define MODBUS_TIMER_T1    14
.................... #define MODBUS_TIMER_T2    15
.................... 
.................... #ifndef MODBUS_PROTOCOL
....................  #define MODBUS_PROTOCOL MODBUS_PROTOCOL_SERIAL
.................... #endif
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL)
....................  #ifndef MODBUS_TYPE
....................   #define MODBUS_TYPE MODBUS_TYPE_MASTER
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_TYPE
....................   #define MODBUS_SERIAL_TYPE MODBUS_RTU
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_INT_SOURCE
....................   #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA   // Select between external interrupt
....................  #endif                                             // or asynchronous serial interrupt
.................... 
....................  #ifndef MODBUS_SERIAL_BAUD
....................   #define MODBUS_SERIAL_BAUD 9600
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_RX_PIN
....................   #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_TX_PIN
....................   #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_ENABLE_PIN
....................   #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high.
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_RX_ENABLE
....................   #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low.
....................  #endif
.................... 
....................  #ifndef MODBUS_PARITY
....................   #define MODBUS_PARITY "EVEN"
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_TIMEOUT
....................   #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII)
....................    #define MODBUS_SERIAL_TIMEOUT    1000000
....................   #else
....................    #define MODBUS_SERIAL_TIMEOUT      10000     //in us
....................   #endif
....................  #endif
.................... 
....................  #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE
....................   #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer
....................  #endif
.................... 
....................  #ifndef MODBUS_TIMER_UPDATE
....................   #define MODBUS_TIMER_UPDATE MODBUS_TIMER_ISR
....................  #endif
.................... 
....................  #ifndef MODBUS_TIMER_USED
....................   #define MODBUS_TIMER_USED MODBUS_TIMER_T1
....................  #endif
.................... 
.................... #else ///////////////////////// MODBUS TCP/IP PROTOCOL /////////////////////////
....................  #ifndef MODBUS_TYPE
....................   #define MODBUS_TYPE   MODBUS_TYPE_CLIENT
....................  #endif
.................... 
....................  #ifndef MODBUS_SERVER_LISTEN_PORT
....................   #define MODBUS_SERVER_LISTEN_PORT    502   //this is the default listen port for MODBUS TCP/IP protocol
....................  #endif
.................... 
....................  #if (MODBUS_TYPE == MODBUS_TYPE_SERVER)
....................   #ifndef MODBUS_LISTEN_SOCKETS
....................    #define MODBUS_LISTEN_SOCKETS     1
....................   #endif
....................  #endif
.................... 
....................  #ifndef MODBUS_BUFFER_SIZE
....................   #define MODBUS_BUFFER_SIZE   64
....................  #endif
.................... 
....................  #ifndef MODBUS_SERVER_TIMEOUT
....................   #define MODBUS_SERVER_TIMEOUT  5  //time in seconds that client will wait for server response before timeout
....................  #endif
.................... 
....................  #if (MODBUS_TYPE == MODBUS_TYPE_CLIENT)
....................   #ifndef MODBUS_SERVER_ADDR_0
....................    #define MODBUS_SERVER_ADDR_0  192
....................    #define MODBUS_SERVER_ADDR_1  168
....................    #define MODBUS_SERVER_ADDR_2  100
....................    #define MODBUS_SERVER_ADDR_3  140
....................   #endif
....................  #endif
.................... 
....................  #ifndef debug_printf
....................   #define debug_printf(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u)
....................  #endif
.................... 
.................... #endif
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP)
....................  #include <modbus_phy_layer_tcpip.h>
.................... #else
....................  #include <modbus_phy_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_phy_layer.h                                ////
.................... ////                                                                                  ////
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////                                                                                  ////
.................... ////  Sept 22, 2020       Updated TRMT bit variable for PIC18 devices with new UART   ////
.................... ////                      peripherial.  Added support for using UART5 and UART6 for   ////
.................... ////                      devices that have UART5 and UART6 peripherals.              ////
.................... ////                                                                                  ////
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    ////
.................... ////                      file from modbus.c                                          ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_PHY_LAYER_H
.................... #define MODBUS_PHY_LAYER_H
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    modbus_timeout_enabled = 0;\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #else
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
....................    #if defined(__PCD__)
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #word TXSTA=getenv("SFR:U1STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #word TXSTA=getenv("SFR:U2STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #word TXSTA=getenv("SFR:U3STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #word TXSTA=getenv("SFR:U4STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #word TXSTA=getenv("SFR:U5STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #word TXSTA=getenv("SFR:U6STA")
....................          #bit TRMT=TXSTA.8
....................       #endif
....................    #else
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #if getenv("sfr_valid:U1ERRIR")
....................             #byte TXSTA=getenv("SFR:U1ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA")
....................             #byte TXSTA=getenv("sfr:TXSTA")
....................             #bit TRMT=TXSTA.1
....................          #elif getenv("sfr_valid:TXSTA1")
....................             #byte TXSTA=getenv("sfr:TXSTA1")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX1STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #if getenv("sfr_valid:U2ERRIR")
....................             #byte TXSTA=getenv("SFR:U2ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA2")
....................             #byte TXSTA=getenv("sfr:TXSTA2")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX2STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #if getenv("sfr_valid:U3ERRIR")
....................             #byte TXSTA=getenv("SFR:U3ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA3")
....................             #byte TXSTA=getenv("sfr:TXSTA3")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX3STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #if getenv("sfr_valid:U4ERRIR")
....................             #byte TXSTA=getenv("SFR:U4ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA4")
....................             #byte TXSTA=getenv("sfr:TXSTA4")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX4STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #if getenv("sfr_valid:U5ERRIR")
....................             #byte TXSTA=getenv("SFR:U5ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA5")
....................             #byte TXSTA=getenv("sfr:TXSTA5")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX5STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #if getenv("sfr_valid:U6ERRIR")
....................             #byte TXSTA=getenv("SFR:U6ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA6")
....................             #byte TXSTA=getenv("sfr:TXSTA6")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX6STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #endif
....................    #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.
.................... The first exception is the only one that is not part of the protocol
.................... specification.  The TIMEOUT exception is returned when no slave
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    unsigned int8 address;
....................    unsigned int8 len;                       //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Custom Commands                                                             ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_putc(unsigned int8 c)                                             ////
.................... ////    - Sends a character onto the serial line                                      ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func);
.................... 
.................... // Purpose:    Sends a message stop
.................... // Inputs:     none
.................... // Outputs:    None
.................... void modbus_serial_send_stop();
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(unsigned int8 c);
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Init                                                                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void RCV_ON(void);
.................... 
.................... #endif //MODBUS_PHY_LAYER_H
.................... 
.................... #endif
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP)
....................  #include <modbus_app_layer_tcpip.h>
.................... #else
....................  #include <modbus_app_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_app_layer.h                                ////
.................... ////                                                                                  ////
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_APP_LAYER_H
.................... #define MODBUS_APP_LAYER_H
.................... 
.................... #include <modbus_phy_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_phy_layer.h                                ////
.................... ////                                                                                  ////
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////                                                                                  ////
.................... ////  Sept 22, 2020       Updated TRMT bit variable for PIC18 devices with new UART   ////
.................... ////                      peripherial.  Added support for using UART5 and UART6 for   ////
.................... ////                      devices that have UART5 and UART6 peripherals.              ////
.................... ////                                                                                  ////
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    ////
.................... ////                      file from modbus.c                                          ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_PHY_LAYER_H
.................... #define MODBUS_PHY_LAYER_H
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    modbus_timeout_enabled = 0;\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #else
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
....................    #if defined(__PCD__)
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #word TXSTA=getenv("SFR:U1STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #word TXSTA=getenv("SFR:U2STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #word TXSTA=getenv("SFR:U3STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #word TXSTA=getenv("SFR:U4STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #word TXSTA=getenv("SFR:U5STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #word TXSTA=getenv("SFR:U6STA")
....................          #bit TRMT=TXSTA.8
....................       #endif
....................    #else
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #if getenv("sfr_valid:U1ERRIR")
....................             #byte TXSTA=getenv("SFR:U1ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA")
....................             #byte TXSTA=getenv("sfr:TXSTA")
....................             #bit TRMT=TXSTA.1
....................          #elif getenv("sfr_valid:TXSTA1")
....................             #byte TXSTA=getenv("sfr:TXSTA1")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX1STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #if getenv("sfr_valid:U2ERRIR")
....................             #byte TXSTA=getenv("SFR:U2ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA2")
....................             #byte TXSTA=getenv("sfr:TXSTA2")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX2STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #if getenv("sfr_valid:U3ERRIR")
....................             #byte TXSTA=getenv("SFR:U3ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA3")
....................             #byte TXSTA=getenv("sfr:TXSTA3")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX3STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #if getenv("sfr_valid:U4ERRIR")
....................             #byte TXSTA=getenv("SFR:U4ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA4")
....................             #byte TXSTA=getenv("sfr:TXSTA4")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX4STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #if getenv("sfr_valid:U5ERRIR")
....................             #byte TXSTA=getenv("SFR:U5ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA5")
....................             #byte TXSTA=getenv("sfr:TXSTA5")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX5STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #if getenv("sfr_valid:U6ERRIR")
....................             #byte TXSTA=getenv("SFR:U6ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA6")
....................             #byte TXSTA=getenv("sfr:TXSTA6")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX6STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #endif
....................    #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.
.................... The first exception is the only one that is not part of the protocol
.................... specification.  The TIMEOUT exception is returned when no slave
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    unsigned int8 address;
....................    unsigned int8 len;                       //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Custom Commands                                                             ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_putc(unsigned int8 c)                                             ////
.................... ////    - Sends a character onto the serial line                                      ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func);
.................... 
.................... // Purpose:    Sends a message stop
.................... // Inputs:     none
.................... // Outputs:    None
.................... void modbus_serial_send_stop();
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(unsigned int8 c);
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Init                                                                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void RCV_ON(void);
.................... 
.................... #endif //MODBUS_PHY_LAYER_H
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Shared API                                                                       ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init();
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit();
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Master Api                                                                       ////
.................... ////                                                                                  ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on);
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value);
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(unsigned int8 address);
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data);
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(unsigned int8 address);
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(unsigned int8 address);
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int8 *values);
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int16 *values);
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(unsigned int8 address);
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_read_sub_request *request);
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_write_sub_request *request);
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask);
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start,
....................                                     unsigned int16 read_quantity, unsigned int16 write_start,
....................                                     unsigned int16 write_quantity,
....................                                     unsigned int16 *write_registers_value);
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address);
.................... 
.................... #else
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Slave API                                                                        ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    unsigned int8 record_length;
....................    unsigned int8 reference_type;
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data);
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     unsigned int8 *input_data);
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *reg_data);
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *input_data);
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address,
....................                                     unsigned int16 output_value);
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address,
....................                                         unsigned int16 reg_value);
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data);
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data);
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status,
....................                                         unsigned int16 event_count);
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status,
....................                                     unsigned int16 event_count, unsigned int16 message_count,
....................                                     unsigned int8 *events, unsigned int8 events_len);
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                         unsigned int16 quantity);
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                             unsigned int16 quantity);
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status,
....................                               unsigned int8 *data, unsigned int8 data_len);
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_read_sub_request_rsp *request);
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_write_sub_request_rsp *request);
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask);
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len,
....................                                                 unsigned int16 *data);
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data);
.................... 
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error);
.................... #endif //MODBUS_TYPE
.................... 
.................... #endif //MODBUS_APP_LAYER_H
.................... 
.................... #endif
.................... 
.................... #endif //MODBUS_H
.................... 
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL)
....................  #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
....................   #include <modbus_phy_layer_rtu.c>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                              modbus_phy_layer_rtu.c                              ////
.................... ////                                                                                  ////
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_PHY_LAYER_RTU_C
.................... #define MODBUS_PHY_LAYER_RTU_C
.................... 
.................... #include <modbus_phy_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_phy_layer.h                                ////
.................... ////                                                                                  ////
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////                                                                                  ////
.................... ////  Sept 22, 2020       Updated TRMT bit variable for PIC18 devices with new UART   ////
.................... ////                      peripherial.  Added support for using UART5 and UART6 for   ////
.................... ////                      devices that have UART5 and UART6 peripherals.              ////
.................... ////                                                                                  ////
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    ////
.................... ////                      file from modbus.c                                          ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_PHY_LAYER_H
.................... #define MODBUS_PHY_LAYER_H
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU)
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    modbus_timeout_enabled = 0;\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #else
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\
.................... {\
....................    if(address)\
....................    {\
....................       while(!modbus_kbhit() && --modbus_serial_wait)\
....................          delay_us(1);\
....................       if(!modbus_serial_wait)\
....................          modbus_rx.error=TIMEOUT;\
....................    }\
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\
.................... }
.................... #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
....................    #if defined(__PCD__)
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #word TXSTA=getenv("SFR:U1STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #word TXSTA=getenv("SFR:U2STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #word TXSTA=getenv("SFR:U3STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #word TXSTA=getenv("SFR:U4STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #word TXSTA=getenv("SFR:U5STA")
....................          #bit TRMT=TXSTA.8
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #word TXSTA=getenv("SFR:U6STA")
....................          #bit TRMT=TXSTA.8
....................       #endif
....................    #else
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA)
....................          #if getenv("sfr_valid:U1ERRIR")
....................             #byte TXSTA=getenv("SFR:U1ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA")
....................             #byte TXSTA=getenv("sfr:TXSTA")
....................             #bit TRMT=TXSTA.1
....................          #elif getenv("sfr_valid:TXSTA1")
....................             #byte TXSTA=getenv("sfr:TXSTA1")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX1STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2)
....................          #if getenv("sfr_valid:U2ERRIR")
....................             #byte TXSTA=getenv("SFR:U2ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA2")
....................             #byte TXSTA=getenv("sfr:TXSTA2")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX2STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3)
....................          #if getenv("sfr_valid:U3ERRIR")
....................             #byte TXSTA=getenv("SFR:U3ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA3")
....................             #byte TXSTA=getenv("sfr:TXSTA3")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX3STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4)
....................          #if getenv("sfr_valid:U4ERRIR")
....................             #byte TXSTA=getenv("SFR:U4ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA4")
....................             #byte TXSTA=getenv("sfr:TXSTA4")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX4STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5)
....................          #if getenv("sfr_valid:U5ERRIR")
....................             #byte TXSTA=getenv("SFR:U5ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA5")
....................             #byte TXSTA=getenv("sfr:TXSTA5")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX5STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6)
....................          #if getenv("sfr_valid:U6ERRIR")
....................             #byte TXSTA=getenv("SFR:U6ERRIR")
....................             #bit TRMT=TXSTA.7
....................          #elif getenv("sfr_valid:TXSTA6")
....................             #byte TXSTA=getenv("sfr:TXSTA6")
....................             #bit TRMT=TXSTA.1
....................          #else
....................             #byte TXSTA=getenv("sfr:TX6STA")
....................             #bit TRMT=TXSTA.1
....................          #endif
....................       #endif
....................    #endif
.................... #endif
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT)
.................... #define WAIT_FOR_HW_BUFFER()\
.................... {\
....................    while(!TRMT);\
.................... }
.................... #endif
.................... 
.................... int1 modbus_serial_new=0;
.................... 
.................... /********************************************************************
.................... These exceptions are defined in the MODBUS protocol.  These can be
.................... used by the slave to communicate problems with the transmission back
.................... to the master who can also use these to easily check the exceptions.
.................... The first exception is the only one that is not part of the protocol
.................... specification.  The TIMEOUT exception is returned when no slave
.................... responds to the master's request within the timeout period.
.................... ********************************************************************/
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11,
.................... TIMEOUT=12} exception;
.................... 
.................... /********************************************************************
.................... These functions are defined in the MODBUS protocol.  These can be
.................... used by the slave to check the incomming function.  See
.................... ex_modbus_slave.c for example usage.
.................... ********************************************************************/
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02,
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04,
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06,
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08,
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C,
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10,
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14,
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16,
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function;
.................... 
.................... /********************************************************************
.................... Our receive struct.  This is used when receiving data as a master or
.................... slave.  Once a message is sent to you with your address, you should
.................... begin processing that message.  Refer to ex_modbus_slave.c to see
.................... how to properly use this structure.
.................... ********************************************************************/
.................... struct
.................... {
....................    unsigned int8 address;
....................    unsigned int8 len;                       //number of bytes in the message received
....................    function func;                           //the function of the message received
....................    exception error;                         //error recieved, if any
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received
.................... } modbus_rx;
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Custom Commands                                                             ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_start(address,func)                                          ////
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data ////
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_send_stop()                                                       ////
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  ////
.................... ////                                                                                  ////
.................... ////  modbus_serial_putc(unsigned int8 c)                                             ////
.................... ////    - Sends a character onto the serial line                                      ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func);
.................... 
.................... // Purpose:    Sends a message stop
.................... // Inputs:     none
.................... // Outputs:    None
.................... void modbus_serial_send_stop();
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(unsigned int8 c);
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////  For Init                                                                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void RCV_ON(void);
.................... 
.................... #endif //MODBUS_PHY_LAYER_H
.................... 
.................... 
.................... #if (MODBUS_TIMER_USED == MODBUS_TIMER_T1)
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR)
....................     #USE TIMER(TIMER=1,TICK=.1ms,BITS=16, ISR)
*
0326:  MOVFF  7F,00
032A:  MOVFF  80,01
032E:  CLRF   02
0330:  BCF    FD8.0
0332:  RLCF   00,F
0334:  RLCF   01,F
0336:  RLCF   02,F
0338:  BCF    FD8.0
033A:  RLCF   00,F
033C:  RLCF   01,F
033E:  RLCF   02,F
0340:  BCF    FD8.0
0342:  RLCF   00,F
0344:  RLCF   01,F
0346:  RLCF   02,F
0348:  BCF    FD8.0
034A:  RLCF   00,F
034C:  RLCF   01,F
034E:  RLCF   02,F
0350:  BCF    FD8.0
0352:  RLCF   00,F
0354:  RLCF   01,F
0356:  RLCF   02,F
0358:  MOVFF  02,5F
035C:  MOVFF  01,FCF
0360:  MOVFF  00,FCE
0364:  RETURN 0
*
0962:  MOVFF  5F,01
0966:  MOVF   FCE,W
0968:  MOVFF  FCF,03
096C:  BCF    F9D.0
096E:  MOVWF  02
0970:  MOVF   5F,W
0972:  SUBWF  01,W
0974:  BZ    097E
0976:  MOVF   FCE,W
0978:  MOVFF  FCF,03
097C:  BRA    0980
097E:  MOVF   02,W
0980:  MOVWF  00
0982:  MOVFF  03,01
0986:  MOVFF  5F,02
098A:  RRCF   02,F
098C:  RRCF   01,F
098E:  RRCF   00,F
0990:  RRCF   02,F
0992:  RRCF   01,F
0994:  RRCF   00,F
0996:  RRCF   02,F
0998:  RRCF   01,F
099A:  RRCF   00,F
099C:  RRCF   02,F
099E:  RRCF   01,F
09A0:  RRCF   00,F
09A2:  RRCF   02,F
09A4:  RRCF   01,F
09A6:  RRCF   00,F
09A8:  BSF    F9D.0
09AA:  GOTO   09EA (RETURN)
....................   #else
....................     #USE TIMER(TIMER=1,TICK=.1ms,BITS=16, NOISR)
....................   #endif
.................... #elif (MODBUS_TIMER_USED == MODBUS_TIMER_T2)
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR)
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, ISR)
....................   #else
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, NOISR)
....................   #endif
.................... #endif
.................... 
.................... #define MODBUS_GETDATA_TIMEOUT 40
.................... 
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
*
02F6:  BTFSS  F9E.5
02F8:  BRA    02F6
02FA:  MOVFF  FAB,60
02FE:  MOVFF  FAE,01
0302:  MOVLW  08
0304:  MOVWF  7F
0306:  CLRF   7E
0308:  MOVFF  FAE,00
030C:  MOVF   00,W
030E:  XORWF  7E,F
0310:  RRCF   00,F
0312:  DECFSZ 7F,F
0314:  BRA    030C
0316:  MOVLW  01
0318:  ANDWF  7E,W
031A:  XORWF  60,F
031C:  BTFSS  60.1
031E:  BRA    0324
0320:  BCF    FAB.4
0322:  BSF    FAB.4
0324:  RETURN 0
*
0666:  MOVLW  08
0668:  MOVWF  01
066A:  CLRF   7C
066C:  MOVFF  7B,00
0670:  MOVF   00,W
0672:  XORWF  7C,F
0674:  RRCF   00,F
0676:  DECFSZ 01,F
0678:  BRA    0670
067A:  BTFSS  F9E.4
067C:  BRA    067A
067E:  MOVLW  FE
0680:  ANDWF  FAC,F
0682:  BTFSC  7C.0
0684:  BSF    FAC.0
0686:  MOVFF  7B,FAD
068A:  GOTO   0694 (RETURN)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART5, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART5, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART5, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA5);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA6 )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART6, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART6, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART6, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors)
....................   #endif
....................    #define RCV_OFF() {disable_interrupts(INT_RDA6);}
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT )
....................   #if MODBUS_PARITY == "EVEN"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, disable_ints)
....................   #elif MODBUS_PARITY == "ODD"
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, disable_ints)
....................   #else
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, disable_ints)
....................   #endif
....................    #if defined(__PCD__)
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);}
....................    #else
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);}
....................    #endif
.................... #else
....................    #error Please define a correct interrupt source
.................... #endif
.................... 
.................... /* status of between byte timeout */
.................... int1 modbus_timeout_enabled = FALSE;
.................... 
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
.................... unsigned int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
.................... #endif
.................... 
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0;
.................... 
.................... 
.................... /*Global value holding our current CRC value.*/
.................... union
.................... {
....................    unsigned int8 b[2];
....................    unsigned int16 d;
.................... } modbus_serial_crc;
.................... 
.................... 
.................... /* Table of CRC values for highorder byte */
.................... const unsigned char modbus_auchCRCHi[] = {
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
.................... 0x40
.................... };
.................... 
.................... /* Table of CRC values for loworder byte */
.................... const unsigned char modbus_auchCRCLo[] = {
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
.................... 0x40
.................... };
.................... 
.................... // Purpose:    Enable data reception
.................... // Inputs:     None
.................... // Outputs:    None
.................... void RCV_ON(void)
.................... {
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag.
*
0402:  BTFSS  F9E.5
0404:  BRA    0416
0406:  CLRF   19
0408:  BTFSC  FF2.7
040A:  BSF    19.7
040C:  BCF    FF2.7
040E:  RCALL  02F6
0410:  BTFSC  19.7
0412:  BSF    FF2.7
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
0414:  BRA    0402
....................          clear_interrupt(INT_RDA);
0416:  MOVF   FAE,W
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
....................          clear_interrupt(INT_RDA2);
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3)
....................          clear_interrupt(INT_RDA3);
....................       #else
....................          clear_interrupt(INT_RDA4);
....................       #endif
.................... 
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)
....................          output_low(MODBUS_SERIAL_RX_ENABLE);
0418:  BCF    F95.2
041A:  BCF    F8C.2
....................       #endif
.................... 
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
....................         enable_interrupts(INT_RDA);
041C:  BSF    F9D.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
....................         enable_interrupts(INT_RDA2);
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3)
....................         enable_interrupts(INT_RDA3);
....................       #else
....................         enable_interrupts(INT_RDA4);
....................       #endif
....................    #else
041E:  RETURN 0
....................       #if defined(__PCD__)
....................          clear_interrupt(INT_EXT0);
....................       #else
....................          clear_interrupt(INT_EXT);
....................       #endif
.................... 
....................       ext_int_edge(H_TO_L);
.................... 
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)
....................          output_low(MODBUS_SERIAL_RX_ENABLE);
....................       #endif
.................... 
....................       #if defined(__PCD__)
....................          enable_interrupts(INT_EXT0);
....................       #else
....................          enable_interrupts(INT_EXT);
....................       #endif
....................    #endif
.................... }
.................... 
.................... // Purpose:    Start our timeout timer
.................... // Inputs:     Enable, used to turn timer on/off
.................... // Outputs:    None
.................... // Not used for ASCII mode
.................... void modbus_enable_timeout(int1 enable)
.................... {
....................    modbus_timeout_enabled = enable;
*
0366:  BCF    1A.1
0368:  BTFSC  7E.0
036A:  BSF    1A.1
....................    set_ticks(0);
036C:  CLRF   x80
036E:  CLRF   7F
0370:  RCALL  0326
0372:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Handles a timeout when waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... // Not used for ASCII mode
.................... void modbus_timeout_now(void)
.................... {
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new))
*
09AE:  MOVF   61,W
09B0:  SUBLW  02
09B2:  BNZ   09C8
09B4:  MOVF   62,F
09B6:  BNZ   09C8
09B8:  MOVF   63,F
09BA:  BNZ   09C8
09BC:  BTFSC  1A.0
09BE:  BRA    09C8
....................    {
....................       modbus_rx.len-=2;
09C0:  MOVLW  02
09C2:  SUBWF  1C,F
....................       modbus_serial_new=TRUE;
09C4:  BSF    1A.0
....................    } else {
09C6:  BRA    09CA
....................       modbus_serial_new=FALSE;
09C8:  BCF    1A.0
....................    }
.................... 
....................    modbus_serial_crc.d=0xFFFF;
09CA:  SETF   63
09CC:  SETF   62
....................    modbus_serial_state=MODBUS_GETADDY;
09CE:  CLRF   61
09D0:  CLRF   19
09D2:  BTFSC  FF2.7
09D4:  BSF    19.7
09D6:  BCF    FF2.7
....................    modbus_enable_timeout(FALSE);
09D8:  CLRF   7E
09DA:  RCALL  0366
09DC:  BTFSC  19.7
09DE:  BSF    FF2.7
09E0:  GOTO   09FE (RETURN)
.................... }
.................... 
.................... // Purpose:    Check if we have timed out waiting for a response
.................... // Inputs:     None
.................... // Outputs:    None
.................... // Not used for ASCII mode
.................... void modbus_check_timeout(void)
.................... {
....................    #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_NOISR)
....................    //get_ticks() must be called more often than the timer overflow
....................    //rate, and the get_ticks() below will not always be called
....................    //due to short circuit evaluation
....................    get_ticks();
....................    #endif
....................    //modbus_timeout_enabled must be checked before get_ticks()
....................    //so that if an interrupt happens it cannot be enabled after
....................    //an old timer value is used in comparison
....................    if(modbus_timeout_enabled && (get_ticks() > MODBUS_GETDATA_TIMEOUT))
09E4:  BTFSS  1A.1
09E6:  BRA    09FE
09E8:  BRA    0962
09EA:  MOVFF  01,6E
09EE:  MOVFF  00,6D
09F2:  MOVF   6E,F
09F4:  BNZ   09FC
09F6:  MOVF   6D,W
09F8:  SUBLW  28
09FA:  BC    09FE
....................    {
....................      modbus_timeout_now();
09FC:  BRA    09AE
....................    }
09FE:  GOTO   0A04 (RETURN)
.................... }
.................... 
.................... // Purpose:    Calculate crc of data and updates global crc
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_calc_crc(char data)
.................... {
....................    unsigned int8 uIndex ; // will index into CRC lookup table
.................... 
....................    uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC
*
0374:  MOVF   63,W
0376:  XORWF  7E,W
0378:  MOVWF  7F
....................    modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex];
037A:  CLRF   03
037C:  MOVF   7F,W
037E:  RCALL  00BA
0380:  MOVWF  01
0382:  MOVF   62,W
0384:  XORWF  01,W
0386:  MOVWF  63
....................    modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex];
0388:  CLRF   03
038A:  MOVF   7F,W
038C:  RCALL  01CA
038E:  MOVWF  62
0390:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Puts a character onto the serial line
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_putc(unsigned int8 c)
.................... {
....................    fputc(c, MODBUS_SERIAL);
*
068E:  MOVFF  7A,7B
0692:  BRA    0666
0694:  CLRF   19
0696:  BTFSC  FF2.7
0698:  BSF    19.7
069A:  BCF    FF2.7
....................    modbus_calc_crc(c);
069C:  MOVFF  7A,7E
06A0:  RCALL  0374
06A2:  BTFSC  19.7
06A4:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact
06A6:  MOVLW  45
06A8:  MOVWF  00
06AA:  DECFSZ 00,F
06AC:  BRA    06AA
06AE:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Send a message over the RS485 bus
.................... // Inputs:     1) The destination address
.................... //             2) The number of bytes of data to send
.................... //             3) A pointer to the data to send
.................... //             4) The length of the data
.................... // Outputs:    TRUE if successful
.................... //             FALSE if failed
.................... // Note:       Format:  source | destination | data-length | data | checksum
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func)
.................... {
....................    modbus_serial_crc.d=0xFFFF;
06B0:  SETF   63
06B2:  SETF   62
....................    modbus_serial_new=FALSE;
06B4:  BCF    1A.0
.................... 
....................    RCV_OFF();
06B6:  BCF    F9D.5
.................... 
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)
....................    output_high(MODBUS_SERIAL_ENABLE_PIN);
.................... #endif
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
06B8:  MOVLW  F2
06BA:  MOVWF  00
06BC:  DECFSZ 00,F
06BE:  BRA    06BC
06C0:  NOP   
.................... 
....................    modbus_serial_putc(to);
06C2:  MOVFF  78,7A
06C6:  RCALL  068E
....................    modbus_serial_putc(func);
06C8:  MOVFF  79,7A
06CC:  RCALL  068E
06CE:  RETURN 0
.................... }
.................... 
.................... // Purpose:    Ends a message over the RS485 Bus
.................... // Inputs:     Character
.................... // Outputs:    None
.................... void modbus_serial_send_stop()
.................... {
....................    unsigned int8 crc_low, crc_high;
.................... 
....................    crc_high=modbus_serial_crc.b[1];
06D0:  MOVFF  63,79
....................    crc_low=modbus_serial_crc.b[0];
06D4:  MOVFF  62,78
.................... 
....................    modbus_serial_putc(crc_high);
06D8:  MOVFF  79,7A
06DC:  RCALL  068E
....................    modbus_serial_putc(crc_low);
06DE:  MOVFF  78,7A
06E2:  RCALL  068E
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT)
....................    WAIT_FOR_HW_BUFFER();
06E4:  BTFSS  FAC.1
06E6:  BRA    06E4
.................... #endif
.................... 
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay
06E8:  MOVLW  F2
06EA:  MOVWF  00
06EC:  DECFSZ 00,F
06EE:  BRA    06EC
06F0:  NOP   
.................... 
....................    RCV_ON();
06F2:  RCALL  0402
.................... 
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
.................... #endif
.................... 
....................    modbus_serial_crc.d=0xFFFF;
06F4:  SETF   63
06F6:  SETF   62
06F8:  RETURN 0
.................... }
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Interrupts    ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA)
.................... #int_rda
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2)
.................... #int_rda2
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3)
.................... #int_rda3
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4)
.................... #int_rda4
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA5)
.................... #int_rda5
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA6)
.................... #int_rda6
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT)
.................... #if defined(__PCD__)
.................... #int_ext1
.................... #else
.................... #int_ext
.................... #endif
.................... #else
.................... #error Please define a correct interrupt source
.................... #endif
.................... void incomming_modbus_serial() {
....................    char c;
....................    c=fgetc(MODBUS_SERIAL);
*
0392:  RCALL  02F6
0394:  MOVFF  01,7D
.................... 
....................    if (!modbus_serial_new)
0398:  BTFSC  1A.0
039A:  BRA    03EC
....................    {
....................       if(modbus_serial_state == MODBUS_GETADDY)
039C:  MOVF   61,F
039E:  BNZ   03B0
....................       {
....................          modbus_serial_crc.d = 0xFFFF;
03A0:  SETF   63
03A2:  SETF   62
....................          modbus_rx.address = c;
03A4:  MOVFF  7D,1B
....................          modbus_serial_state++;
03A8:  INCF   61,F
....................          modbus_rx.len = 0;
03AA:  CLRF   1C
....................          modbus_rx.error=0;
03AC:  CLRF   1E
....................       }
03AE:  BRA    03E0
....................       else if(modbus_serial_state == MODBUS_GETFUNC)
03B0:  DECFSZ 61,W
03B2:  BRA    03BC
....................       {
....................          modbus_rx.func = c;
03B4:  MOVFF  7D,1D
....................          modbus_serial_state++;
03B8:  INCF   61,F
....................       }
03BA:  BRA    03E0
....................       else if(modbus_serial_state == MODBUS_GETDATA)
03BC:  MOVF   61,W
03BE:  SUBLW  02
03C0:  BNZ   03E0
....................       {
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE)
03C2:  MOVF   1C,W
03C4:  SUBLW  3F
03C6:  BC    03CC
....................        {
....................          modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;
03C8:  MOVLW  3F
03CA:  MOVWF  1C
....................        }
....................          modbus_rx.data[modbus_rx.len]=c;
03CC:  CLRF   03
03CE:  MOVF   1C,W
03D0:  ADDLW  1F
03D2:  MOVWF  FE9
03D4:  MOVLW  00
03D6:  ADDWFC 03,W
03D8:  MOVWF  FEA
03DA:  MOVFF  7D,FEF
....................          modbus_rx.len++;
03DE:  INCF   1C,F
....................      }
....................      modbus_enable_timeout(TRUE);
03E0:  MOVLW  01
03E2:  MOVWF  7E
03E4:  RCALL  0366
....................      modbus_calc_crc(c);
03E6:  MOVFF  7D,7E
03EA:  RCALL  0374
.................... 
....................    }
.................... 
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER)
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT;
....................    #endif
.................... }
.................... #endif //MODBUS_PHY_LAYER_RTU_C
.................... 
....................  #elif (MODBUS_SERIAL_TYPE == MODBUS_ASCII)
....................   #include <modbus_phy_layer_ascii.c>
....................  #endif
.................... #else
....................  #include <modbus_phy_layer_tcpip.c>
.................... #endif
.................... 
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP)
....................  #include <modbus_app_layer_tcpip.c>
.................... #else
....................  #include <modbus_app_layer.c>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_app_layer.c                                ////
.................... ////                                                                                  ////
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MODBUS_APP_LAYER_C
.................... #define MODBUS_APP_LAYER_C
.................... 
.................... #include <modbus_app_layer.h>
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                modbus_app_layer.h                                ////
.................... ////                                                                                  ////
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    ////
.................... ////                                                                                  ////
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                                                                                  ////
.................... //// Revision history:                                                                ////
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 ////
.................... ////        This source code may only be used by licensed users of the CCS            ////
.................... ////        C compiler.  This source code may only be distributed to other            ////
.................... ////        licensed users of the CCS C compiler.  No other use,                      ////
.................... ////        reproduction or distribution is permitted without written                 ////
.................... ////        permission.  Derivative programs created using this software              ////
.................... ////        in object code form are not restricted in any way.                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
03EC:  BCF    F9E.5
03EE:  GOTO   006C
.................... #ifndef MODBUS_APP_LAYER_H
.................... #define MODBUS_APP_LAYER_H
.................... 
.................... #include <modbus_phy_layer.h>
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Shared API                                                                       ////
.................... ////                                                                                  ////
.................... ////  modbus_init()                                                                   ////
.................... ////    - Initialize modbus serial communication system                               ////
.................... ////                                                                                  ////
.................... ////  modbus_kbhit()                                                                  ////
.................... ////    - Used to check if a packet has been received.                                ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init();
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit();
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Master Api                                                                       ////
.................... ////                                                                                  ////
.................... ////  All master API functions return 0 on success.                                   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     ////
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            ////
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         ////
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           ////
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   ////
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           ////
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_exception_status(address)                                 ////
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             ////
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_counter(address)                                ////
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_get_comm_event_log(address)                                    ////
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   ////
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.////
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  ////
.................... ////                    coils.                                                        ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)///
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. ////
.................... ////    - Special Note: values is a pointer to an int8 array                          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_report_slave_id(address)                                       ////
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  ////
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 ////
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)////
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          ////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,////
.................... ////                            write_start,write_quantity, *write_registers_value)   ////
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          ////
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request.  These
.................... functions take in one of these structs.
.................... Please refer to the MODBUS protocol specification if you do not
.................... understand the members of the structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
.................... } modbus_read_sub_request;
.................... 
.................... typedef struct _modbus_write_sub_request
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8];
.................... } modbus_write_sub_request;
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity);
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on);
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value);
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(unsigned int8 address);
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data);
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(unsigned int8 address);
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(unsigned int8 address);
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int8 *values);
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int16 *values);
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(unsigned int8 address);
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_read_sub_request *request);
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_write_sub_request *request);
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask);
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start,
....................                                     unsigned int16 read_quantity, unsigned int16 write_start,
....................                                     unsigned int16 write_quantity,
....................                                     unsigned int16 *write_registers_value);
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address);
.................... 
.................... #else
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Slave API                                                                        ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       ////
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             ////
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            ////
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            ////
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          ////
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            ////
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_exception_status_rsp(address, data)                            ////
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              ////
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        ////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              ////
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    ////
.................... ////                                   *events, events_len)                           ////
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            ////
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        ////
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.////
.................... ////                                                                                  ////
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     ////
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   ////
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   ////
.................... ////                                                                                  ////
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  ////
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  ////
.................... ////                                                                                  ////
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) ////
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         ////
.................... ////                                                                                  ////
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           ////
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification////
.................... ////                                                                                  ////
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         ////
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    ////
.................... ////                                                                                  ////
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            ////
.................... ////    - Wrapper to send an exception response.  See exception list below.           ////
.................... ////                                                                                  ////
.................... //// Exception List:                                                                  ////
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     ////
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      ////
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            ////
.................... ////                                                                                  ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following structs are used for read/write_sub_request_rsp.  These
.................... functions take in one of these structs.  Please refer to the MODBUS
.................... protocol specification if you do not understand the members of the
.................... structure.
.................... ********************************************************************/
.................... typedef struct _modbus_read_sub_request_rsp
.................... {
....................    unsigned int8 record_length;
....................    unsigned int8 reference_type;
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3];
.................... } modbus_read_sub_request_rsp;
.................... 
.................... typedef struct _modbus_write_sub_request_rsp
.................... {
....................    unsigned int8 reference_type;
....................    unsigned int16 file_number;
....................    unsigned int16 record_number;
....................    unsigned int16 record_length;
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8];
.................... } modbus_write_sub_request_rsp;
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data);
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     unsigned int8 *input_data);
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *reg_data);
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *input_data);
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address,
....................                                     unsigned int16 output_value);
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address,
....................                                         unsigned int16 reg_value);
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data);
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data);
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status,
....................                                         unsigned int16 event_count);
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status,
....................                                     unsigned int16 event_count, unsigned int16 message_count,
....................                                     unsigned int8 *events, unsigned int8 events_len);
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                         unsigned int16 quantity);
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                             unsigned int16 quantity);
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status,
....................                               unsigned int8 *data, unsigned int8 data_len);
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_read_sub_request_rsp *request);
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_write_sub_request_rsp *request);
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask);
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len,
....................                                                 unsigned int16 *data);
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data);
.................... 
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error);
.................... #endif //MODBUS_TYPE
.................... 
.................... #endif //MODBUS_APP_LAYER_H
.................... 
.................... 
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Shared Api                                                                       ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... // Purpose:    Initialize RS485 communication. Call this before
.................... //             using any other RS485 functions.
.................... // Inputs:     None
.................... // Outputs:    None
.................... void modbus_init()
.................... {
....................    output_low(MODBUS_SERIAL_ENABLE_PIN);
*
0420:  BCF    00.0
.................... 
....................    RCV_ON();
0422:  RCALL  0402
.................... 
....................    #if defined(__PCD__)
....................       enable_interrupts(INTR_GLOBAL);
....................    #else
....................       enable_interrupts(GLOBAL);
0424:  MOVLW  C0
0426:  IORWF  FF2,F
....................    #endif
0428:  GOTO   0A84 (RETURN)
.................... }
.................... 
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer
.................... // Inputs:     None
.................... // Outputs:    TRUE if a message was received
.................... //             FALSE if no message is available
.................... // Note:       Data will be filled in at the modbus_rx struct:
.................... int1 modbus_kbhit()
.................... {
....................    #if(MODBUS_SERIAL_TYPE == MODBUS_RTU)
....................    modbus_check_timeout();
*
0A02:  BRA    09E4
....................    #endif
.................... 
....................    if(!modbus_serial_new)
0A04:  BTFSC  1A.0
0A06:  BRA    0A10
....................      return FALSE;
0A08:  MOVLW  00
0A0A:  MOVWF  01
0A0C:  BRA    0A22
0A0E:  BRA    0A1C
....................    else if(modbus_rx.func & 0x80)           //did we receive an error?
0A10:  BTFSS  1D.7
0A12:  BRA    0A1C
....................    {
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true
0A14:  MOVFF  1F,1E
....................       modbus_rx.len = 1;
0A18:  MOVLW  01
0A1A:  MOVWF  1C
....................    }
....................    modbus_serial_new=FALSE;
0A1C:  BCF    1A.0
....................    return TRUE;
0A1E:  MOVLW  01
0A20:  MOVWF  01
0A22:  GOTO   0B04 (RETURN)
.................... }
.................... 
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER)
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Master API                                                                       ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following functions are defined in the MODBUS protocol.  Please
.................... refer to http://www.modbus.org for the purpose of each of these.
.................... All functions take the slaves address as their first parameter.
.................... Each function returns the exception code received from the response.
.................... The function will return 0 if there were no errors in transmission.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_discrete_input
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_holding_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_input_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start reading from
....................            int16      quantity           Amount of addresses to read
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_single_coil
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Address to write into
....................            int1       on                 true for on, false for off
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    if(on)
....................        modbus_serial_putc(0xFF);
....................    else
....................        modbus_serial_putc(0x00);
.................... 
....................    modbus_serial_putc(0x00);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_single_register
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Address to write into
....................            int16      reg_value          Value to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
....................    modbus_serial_putc(make8(reg_address,0));
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
....................    modbus_serial_putc(make8(reg_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_exception_status
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_read_exception_status(unsigned int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... diagnostics
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Subfunction to send
....................            int16      data               Data to send, changes based on subfunction
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_couter
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_counter(unsigned int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... get_comm_event_log
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_get_comm_event_log(unsigned int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_coils
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int1*      values             A pointer to an array holding the values to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int8 *values)
.................... {
....................    unsigned int8 i,count;
.................... 
....................    count = (unsigned int8)((quantity/8));
.................... 
....................    if(quantity%8)
....................       count++;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < count; ++i)
....................       modbus_serial_putc(values[i]);
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_multiple_registers
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Address to start at
....................            int16      quantity           Amount of coils to write to
....................            int16*     values             A pointer to an array holding the data to write
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity,
....................                            unsigned int16 *values)
.................... {
....................    unsigned int8 i,count;
.................... 
....................    count = quantity*2;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_putc(count);
.................... 
....................    for(i=0; i < quantity; ++i)
....................    {
....................       modbus_serial_putc(make8(values[i],1));
....................       modbus_serial_putc(make8(values[i],0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... report_slave_id
.................... Input:     int8       address            Slave Address
.................... Output:    exception                     0 if no error, else the exception
.................... */
.................... exception modbus_report_slave_id(unsigned int8 address)
.................... {
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_read_sub_request *request)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < (byte_count/7); i+=7)
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... write_file_record
.................... Input:     int8                address            Slave Address
....................            int8                byte_count         Number of bytes to read
....................            read_sub_request*   request            Structure holding record/data information
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count,
....................                             modbus_write_sub_request *request)
.................... {
....................    unsigned int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length) &&
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... mask_write_register
.................... Input:     int8       address            Slave Address
....................            int16      reference_address  Address to mask
....................            int16      AND_mask           A mask to AND with the data at reference_address
....................            int16      OR_mask            A mask to OR with the data at reference_address
.................... Output:    exception                              0 if no error, else the exception
.................... */
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers
.................... Input:     int8       address                Slave Address
....................            int16      read_start             Address to start reading
....................            int16      read_quantity          Amount of registers to read
....................            int16      write_start            Address to start writing
....................            int16      write_quantity         Amount of registers to write
....................            int16*     write_registers_value  Pointer to an aray us to write
.................... Output:    exception                         0 if no error, else the exception
.................... */
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start,
....................                                     unsigned int16 read_quantity, unsigned int16 write_start,
....................                                     unsigned int16 write_quantity,
....................                                     unsigned int16 *write_registers_value)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(make8(read_start,1));
....................    modbus_serial_putc(make8(read_start,0));
.................... 
....................    modbus_serial_putc(make8(read_quantity,1));
....................    modbus_serial_putc(make8(read_quantity,0));
.................... 
....................    modbus_serial_putc(make8(write_start, 1));
....................    modbus_serial_putc(make8(write_start, 0));
.................... 
....................    modbus_serial_putc(make8(write_quantity, 1));
....................    modbus_serial_putc(make8(write_quantity, 0));
.................... 
....................    modbus_serial_putc((unsigned int8)(2*write_quantity));
.................... 
....................    for(i=0; i < write_quantity ; i+=2)
....................    {
....................       modbus_serial_putc(make8(write_registers_value[i], 1));
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... /*
.................... read_FIFO_queue
.................... Input:     int8       address           Slave Address
....................            int16      FIFO_address      FIFO address
.................... Output:    exception                    0 if no error, else the exception
.................... */
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(FIFO_address, 1));
....................    modbus_serial_putc(make8(FIFO_address, 0));
.................... 
....................    modbus_serial_send_stop();
.................... 
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE();
.................... 
....................    return modbus_rx.error;
.................... }
.................... 
.................... #else
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... //// Slave API                                                                        ////
.................... //////////////////////////////////////////////////////////////////////////////////////////
.................... 
.................... /********************************************************************
.................... The following slave functions are defined in the MODBUS protocol.
.................... Please refer to http://www.modbus.org for the purpose of each of
.................... these.  All functions take the slaves address as their first
.................... parameter.
.................... ********************************************************************/
.................... 
.................... /*
.................... read_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      coil_data          Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_COILS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*coil_data);
....................       coil_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_discrete_input_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     unsigned int8 *input_data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; ++i)
....................    {
....................       modbus_serial_putc(*input_data);
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_holding_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      reg_data           Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *reg_data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS);
*
0712:  MOVFF  72,78
0716:  MOVLW  03
0718:  MOVWF  79
071A:  RCALL  06B0
.................... 
....................    modbus_serial_putc(byte_count);
071C:  MOVFF  73,7A
0720:  RCALL  068E
.................... 
....................    for(i=0; i < byte_count; i+=2)
0722:  CLRF   76
0724:  MOVF   73,W
0726:  SUBWF  76,W
0728:  BC    0768
....................    {
....................       modbus_serial_putc(make8(*reg_data,1));
072A:  MOVFF  75,03
072E:  MOVFF  74,FE9
0732:  MOVFF  75,FEA
0736:  MOVFF  FEC,7A
073A:  MOVF   FED,F
073C:  MOVFF  FEF,77
0740:  RCALL  068E
....................       modbus_serial_putc(make8(*reg_data,0));
0742:  MOVFF  75,03
0746:  MOVFF  74,FE9
074A:  MOVFF  75,FEA
074E:  MOVFF  FEC,78
0752:  MOVF   FED,F
0754:  MOVFF  FEF,7A
0758:  RCALL  068E
....................       reg_data++;
075A:  MOVLW  02
075C:  ADDWF  74,F
075E:  BTFSC  FD8.0
0760:  INCF   75,F
0762:  MOVLW  02
0764:  ADDWF  76,F
0766:  BRA    0724
....................    }
.................... 
....................    modbus_serial_send_stop();
0768:  RCALL  06D0
076A:  GOTO   082E (RETURN)
.................... }
.................... 
.................... /*
.................... read_input_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int8       byte_count         Number of bytes being sent
....................            int8*      input_data         Pointer to an array of data to send
.................... Output:    void
.................... */
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                         unsigned int16 *input_data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=2)
....................    {
....................       modbus_serial_putc(make8(*input_data,1));
....................       modbus_serial_putc(make8(*input_data,0));
....................       input_data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_coil_rsp
.................... Input:     int8       address            Slave Address
....................            int16      output_address     Echo of output address received
....................            int16      output_value       Echo of output value received
.................... Output:    void
.................... */
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address,
....................                                     unsigned int16 output_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL);
.................... 
....................    modbus_serial_putc(make8(output_address,1));
....................    modbus_serial_putc(make8(output_address,0));
.................... 
....................    modbus_serial_putc(make8(output_value,1));
....................    modbus_serial_putc(make8(output_value,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_single_register_rsp
.................... Input:     int8       address            Slave Address
....................            int16      reg_address        Echo of register address received
....................            int16      reg_value          Echo of register value received
.................... Output:    void
.................... */
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address,
....................                                         unsigned int16 reg_value)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER);
076E:  MOVFF  73,78
0772:  MOVLW  06
0774:  MOVWF  79
0776:  RCALL  06B0
.................... 
....................    modbus_serial_putc(make8(reg_address,1));
0778:  MOVFF  75,7A
077C:  RCALL  068E
....................    modbus_serial_putc(make8(reg_address,0));
077E:  MOVFF  74,7A
0782:  RCALL  068E
.................... 
....................    modbus_serial_putc(make8(reg_value,1));
0784:  MOVFF  77,7A
0788:  RCALL  068E
....................    modbus_serial_putc(make8(reg_value,0));
078A:  MOVFF  76,7A
078E:  RCALL  068E
.................... 
....................    modbus_serial_send_stop();
0790:  RCALL  06D0
0792:  GOTO   088C (RETURN)
.................... }
.................... 
.................... /*
.................... read_exception_status_rsp
.................... Input:     int8       address            Slave Address
.................... Output:    void
.................... */
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS);
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... diagnostics_rsp
.................... Input:     int8       address            Slave Address
....................            int16      sub_func           Echo of sub function received
....................            int16      data               Echo of data received
.................... Output:    void
.................... */
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data)
.................... {
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS);
.................... 
....................    modbus_serial_putc(make8(sub_func,1));
....................    modbus_serial_putc(make8(sub_func,0));
.................... 
....................    modbus_serial_putc(make8(data,1));
....................    modbus_serial_putc(make8(data,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status,
....................                                         unsigned int16 event_count)
.................... {
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... get_comm_event_counter_rsp
.................... Input:     int8       address            Slave Address
....................            int16      status             Status, refer to MODBUS documentation
....................            int16      event_count        Count of events
....................            int16      message_count      Count of messages
....................            int8*      events             Pointer to event data
....................            int8       events_len         Length of event data in bytes
.................... Output:    void
.................... */
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status,
....................                                     unsigned int16 event_count, unsigned int16 message_count,
....................                                     unsigned int8 *events, unsigned int8 events_len)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG);
.................... 
....................    modbus_serial_putc(events_len+6);
.................... 
....................    modbus_serial_putc(make8(status, 1));
....................    modbus_serial_putc(make8(status, 0));
.................... 
....................    modbus_serial_putc(make8(event_count, 1));
....................    modbus_serial_putc(make8(event_count, 0));
.................... 
....................    modbus_serial_putc(make8(message_count, 1));
....................    modbus_serial_putc(make8(message_count, 0));
.................... 
....................    for(i=0; i < events_len; ++i)
....................    {
....................       modbus_serial_putc(*events);
....................       events++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_coils_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of coils written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                         unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS);
.................... 
....................    modbus_serial_putc(make8(start_address,1));
....................    modbus_serial_putc(make8(start_address,0));
.................... 
....................    modbus_serial_putc(make8(quantity,1));
....................    modbus_serial_putc(make8(quantity,0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_multiple_registers_rsp
.................... Input:     int8       address            Slave Address
....................            int16      start_address      Echo of address to start at
....................            int16      quantity           Echo of amount of registers written to
.................... Output:    void
.................... */
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address,
....................                                             unsigned int16 quantity)
.................... {
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS);
0796:  MOVFF  73,78
079A:  MOVLW  10
079C:  MOVWF  79
079E:  RCALL  06B0
.................... 
....................    modbus_serial_putc(make8(start_address,1));
07A0:  MOVFF  75,7A
07A4:  RCALL  068E
....................    modbus_serial_putc(make8(start_address,0));
07A6:  MOVFF  74,7A
07AA:  RCALL  068E
.................... 
....................    modbus_serial_putc(make8(quantity,1));
07AC:  MOVFF  77,7A
07B0:  RCALL  068E
....................    modbus_serial_putc(make8(quantity,0));
07B2:  MOVFF  76,7A
07B6:  RCALL  068E
.................... 
....................    modbus_serial_send_stop();
07B8:  RCALL  06D0
07BA:  GOTO   0948 (RETURN)
.................... }
.................... 
.................... /*
.................... report_slave_id_rsp
.................... Input:     int8       address            Slave Address
....................            int8       slave_id           Slave Address
....................            int8       run_status         Are we running?
....................            int8*      data               Pointer to an array holding the data
....................            int8       data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status,
....................                               unsigned int8 *data, unsigned int8 data_len)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID);
.................... 
....................    modbus_serial_putc(data_len+2);
....................    modbus_serial_putc(slave_id);
.................... 
....................    if(run_status)
....................     modbus_serial_putc(0xFF);
....................    else
....................     modbus_serial_putc(0x00);
.................... 
....................    for(i=0; i < data_len; ++i)
....................    {
....................       modbus_serial_putc(*data);
....................       data++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Number of bytes to send
....................            read_sub_request_rsp*    request            Structure holding record/data information
.................... Output:    void
.................... */
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_read_sub_request_rsp *request)
.................... {
....................    unsigned int8 i=0,j;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    while(i < byte_count);
....................    {
....................       modbus_serial_putc(request->record_length);
....................       modbus_serial_putc(request->reference_type);
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
.................... 
....................       i += (request->record_length)+1;
....................       request++;
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... write_file_record_rsp
.................... Input:     int8                     address            Slave Address
....................            int8                     byte_count         Echo of number of bytes sent
....................            write_sub_request_rsp*   request            Echo of Structure holding record information
.................... Output:    void
.................... */
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,
....................                                     modbus_write_sub_request_rsp *request)
.................... {
....................    unsigned int8 i, j=0;
.................... 
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD);
.................... 
....................    modbus_serial_putc(byte_count);
.................... 
....................    for(i=0; i < byte_count; i+=(7+(j*2)))
....................    {
....................       modbus_serial_putc(request->reference_type);
....................       modbus_serial_putc(make8(request->file_number, 1));
....................       modbus_serial_putc(make8(request->file_number, 0));
....................       modbus_serial_putc(make8(request->record_number, 1));
....................       modbus_serial_putc(make8(request->record_number, 0));
....................       modbus_serial_putc(make8(request->record_length, 1));
....................       modbus_serial_putc(make8(request->record_length, 0));
.................... 
....................       for(j=0; (j < request->record_length); j+=2)
....................       {
....................          modbus_serial_putc(make8(request->data[j], 1));
....................          modbus_serial_putc(make8(request->data[j], 0));
....................       }
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... mask_write_register_rsp
.................... Input:     int8        address            Slave Address
....................            int16       reference_address  Echo of reference address
....................            int16       AND_mask           Echo of AND mask
....................            int16       OR_mask            Echo or OR mask
.................... Output:    void
.................... */
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address,
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask)
.................... {
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER);
.................... 
....................    modbus_serial_putc(make8(reference_address,1));
....................    modbus_serial_putc(make8(reference_address,0));
.................... 
....................    modbus_serial_putc(make8(AND_mask,1));
....................    modbus_serial_putc(make8(AND_mask,0));
.................... 
....................    modbus_serial_putc(make8(OR_mask, 1));
....................    modbus_serial_putc(make8(OR_mask, 0));
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_write_multiple_registers_rsp
.................... Input:     int8        address            Slave Address
....................            int16*      data               Pointer to an array of data
....................            int8        data_len           Length of data in bytes
.................... Output:    void
.................... */
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len,
....................                                                 unsigned int16 *data)
.................... {
....................    unsigned int8 i;
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS);
.................... 
....................    modbus_serial_putc(data_len*2);
.................... 
....................    for(i=0; i < data_len*2; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       FIFO_len           Length of FIFO in bytes
....................            int16*      data               Pointer to an array of data
.................... Output:    void
.................... */
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data)
.................... {
....................    unsigned int8 i;
....................    unsigned int16 byte_count;
.................... 
....................    byte_count = ((FIFO_len*2)+2);
.................... 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE);
.................... 
....................    modbus_serial_putc(make8(byte_count, 1));
....................    modbus_serial_putc(make8(byte_count, 0));
.................... 
....................    modbus_serial_putc(make8(FIFO_len, 1));
....................    modbus_serial_putc(make8(FIFO_len, 0));
.................... 
....................    for(i=0; i < FIFO_len; i+=2)
....................    {
....................       modbus_serial_putc(make8(data[i], 1));
....................       modbus_serial_putc(make8(data[i], 0));
....................    }
.................... 
....................    modbus_serial_send_stop();
.................... }
.................... 
.................... /*
.................... read_FIFO_queue_rsp
.................... Input:     int8        address            Slave Address
....................            int16       func               function to respond to
....................            exception   error              exception response to send
.................... Output:    void
.................... */
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error)
.................... {
....................    modbus_serial_send_start(address, func|0x80);
*
06FA:  MOVF   70,W
06FC:  IORLW  80
06FE:  MOVWF  73
0700:  MOVFF  6F,78
0704:  MOVWF  79
0706:  RCALL  06B0
....................    modbus_serial_putc(error);
0708:  MOVFF  72,7A
070C:  RCALL  068E
....................    modbus_serial_send_stop();
070E:  RCALL  06D0
0710:  RETURN 0
.................... }
.................... 
.................... #endif
.................... #endif //MODBUS_APP_LAYER_C
.................... 
.................... #endif
.................... 
.................... 
.................... #include "flex_lcd420.c" //using 4x20 LCD
.................... // Flex_LCD420.c
.................... 
.................... #define LCD_DB4   PIN_B4
.................... #define LCD_DB5   PIN_B5
.................... #define LCD_DB6   PIN_B6
.................... #define LCD_DB7   PIN_B7
.................... 
.................... #define LCD_RS    PIN_B3
.................... #define LCD_RW    PIN_B2
.................... #define LCD_E     PIN_B1
.................... 
.................... #define USE_RW_PIN   1     
.................... 
.................... 
.................... // These are the line addresses for most 4x20 LCDs.
.................... #define LCD_LINE_1_ADDRESS 0x00
.................... #define LCD_LINE_2_ADDRESS 0x40
.................... #define LCD_LINE_3_ADDRESS 0x14
.................... #define LCD_LINE_4_ADDRESS 0x54
.................... 
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)
.................... 
.................... int8 lcd_line;
.................... 
.................... int8 const LCD_INIT_STRING[4] =
.................... {
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots
....................  0xc,                     // Display on
....................  1,                       // Clear display
....................  6                        // Increment cursor
....................  };
....................                              
.................... 
.................... //-------------------------------------
.................... void lcd_send_nibble(int8 nibble)
.................... {
.................... // Note:  !! converts an integer expression
.................... // to a boolean (1 or 0).
....................  output_bit(LCD_DB4, !!(nibble & 1));
*
0452:  BTFSC  77.0
0454:  BRA    045A
0456:  BCF    F8A.4
0458:  BRA    045C
045A:  BSF    F8A.4
045C:  BCF    F93.4
....................  output_bit(LCD_DB5, !!(nibble & 2)); 
045E:  BTFSC  77.1
0460:  BRA    0466
0462:  BCF    F8A.5
0464:  BRA    0468
0466:  BSF    F8A.5
0468:  BCF    F93.5
....................  output_bit(LCD_DB6, !!(nibble & 4));   
046A:  BTFSC  77.2
046C:  BRA    0472
046E:  BCF    F8A.6
0470:  BRA    0474
0472:  BSF    F8A.6
0474:  BCF    F93.6
....................  output_bit(LCD_DB7, !!(nibble & 8));   
0476:  BTFSC  77.3
0478:  BRA    047E
047A:  BCF    F8A.7
047C:  BRA    0480
047E:  BSF    F8A.7
0480:  BCF    F93.7
.................... 
....................  delay_cycles(1);
0482:  NOP   
....................  output_high(LCD_E);
0484:  BCF    F93.1
0486:  BSF    F8A.1
....................  delay_us(2);
0488:  BRA    048A
048A:  BRA    048C
....................  output_low(LCD_E);
048C:  BCF    F93.1
048E:  BCF    F8A.1
0490:  RETURN 0
.................... }
.................... 
.................... //-----------------------------------
.................... // This sub-routine is only called by lcd_read_byte().
.................... // It's not a stand-alone routine.  For example, the
.................... // R/W signal is set high by lcd_read_byte() before
.................... // this routine is called.     
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_nibble(void)
.................... {
.................... int8 retval;
.................... // Create bit variables so that we can easily set
.................... // individual bits in the retval variable.
.................... #bit retval_0 = retval.0
.................... #bit retval_1 = retval.1
.................... #bit retval_2 = retval.2
.................... #bit retval_3 = retval.3
.................... 
.................... retval = 0;
0492:  CLRF   78
....................    
.................... output_high(LCD_E);
0494:  BCF    F93.1
0496:  BSF    F8A.1
.................... delay_us(1);
0498:  BRA    049A
.................... 
.................... retval_0 = input(LCD_DB4);
049A:  BSF    F93.4
049C:  BCF    78.0
049E:  BTFSC  F81.4
04A0:  BSF    78.0
.................... retval_1 = input(LCD_DB5);
04A2:  BSF    F93.5
04A4:  BCF    78.1
04A6:  BTFSC  F81.5
04A8:  BSF    78.1
.................... retval_2 = input(LCD_DB6);
04AA:  BSF    F93.6
04AC:  BCF    78.2
04AE:  BTFSC  F81.6
04B0:  BSF    78.2
.................... retval_3 = input(LCD_DB7);
04B2:  BSF    F93.7
04B4:  BCF    78.3
04B6:  BTFSC  F81.7
04B8:  BSF    78.3
....................  
.................... output_low(LCD_E);
04BA:  BCF    F93.1
04BC:  BCF    F8A.1
.................... delay_us(1);
04BE:  BRA    04C0
....................    
.................... return(retval);   
04C0:  MOVFF  78,01
04C4:  RETURN 0
.................... }   
.................... #endif
.................... 
.................... //---------------------------------------
.................... // Read a byte from the LCD and return it.
.................... 
.................... #ifdef USE_RW_PIN
.................... int8 lcd_read_byte(void)
.................... {
.................... int8 low;
.................... int8 high;
.................... 
.................... output_high(LCD_RW);
04C6:  BCF    F93.2
04C8:  BSF    F8A.2
.................... delay_cycles(1);
04CA:  NOP   
.................... 
.................... high = lcd_read_nibble();
04CC:  RCALL  0492
04CE:  MOVFF  01,77
.................... 
.................... low = lcd_read_nibble();
04D2:  RCALL  0492
04D4:  MOVFF  01,76
.................... 
.................... return( (high<<4) | low);
04D8:  SWAPF  77,W
04DA:  MOVWF  00
04DC:  MOVLW  F0
04DE:  ANDWF  00,F
04E0:  MOVF   00,W
04E2:  IORWF  76,W
04E4:  MOVWF  01
04E6:  GOTO   04F0 (RETURN)
.................... }
.................... #endif
.................... 
.................... //----------------------------------------
.................... // Send a byte to the LCD.
.................... void lcd_send_byte(int8 address, int8 n)
.................... {
.................... output_low(LCD_RS);
04EA:  BCF    F93.3
04EC:  BCF    F8A.3
.................... 
.................... #ifdef USE_RW_PIN
.................... while(bit_test(lcd_read_byte(),7)) ;
04EE:  BRA    04C6
04F0:  MOVFF  01,76
04F4:  BTFSC  01.7
04F6:  BRA    04EE
.................... #else
.................... delay_us(60); 
.................... #endif
.................... 
.................... if(address)
04F8:  MOVF   74,F
04FA:  BZ    0502
....................    output_high(LCD_RS);
04FC:  BCF    F93.3
04FE:  BSF    F8A.3
0500:  BRA    0506
.................... else
....................    output_low(LCD_RS);
0502:  BCF    F93.3
0504:  BCF    F8A.3
....................      
....................  delay_cycles(1);
0506:  NOP   
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
0508:  BCF    F93.2
050A:  BCF    F8A.2
.................... delay_cycles(1);
050C:  NOP   
.................... #endif
.................... 
.................... output_low(LCD_E);
050E:  BCF    F93.1
0510:  BCF    F8A.1
.................... 
.................... lcd_send_nibble(n >> 4);
0512:  SWAPF  75,W
0514:  MOVWF  76
0516:  MOVLW  0F
0518:  ANDWF  76,F
051A:  MOVFF  76,77
051E:  RCALL  0452
.................... lcd_send_nibble(n & 0xf);
0520:  MOVF   75,W
0522:  ANDLW  0F
0524:  MOVWF  76
0526:  MOVWF  77
0528:  RCALL  0452
052A:  RETURN 0
.................... }
.................... //----------------------------
.................... 
.................... void lcd_init(void)
.................... {
.................... int8 i;
.................... 
.................... lcd_line = 1;
052C:  MOVLW  01
052E:  MOVWF  64
.................... 
.................... output_low(LCD_RS);
0530:  BCF    F93.3
0532:  BCF    F8A.3
.................... 
.................... #ifdef USE_RW_PIN
.................... output_low(LCD_RW);
0534:  BCF    F93.2
0536:  BCF    F8A.2
.................... #endif
.................... 
.................... output_low(LCD_E);
0538:  BCF    F93.1
053A:  BCF    F8A.1
.................... 
.................... // Some LCDs require 15 ms minimum delay after
.................... // power-up.  Others require 30 ms.  I'm going
.................... // to set it to 35 ms, so it should work with
.................... // all of them.
.................... delay_ms(35);         
053C:  MOVLW  23
053E:  MOVWF  70
0540:  RCALL  042C
.................... 
.................... for(i=0 ;i < 3; i++)
0542:  CLRF   6D
0544:  MOVF   6D,W
0546:  SUBLW  02
0548:  BNC   055A
....................    {
....................     lcd_send_nibble(0x03);
054A:  MOVLW  03
054C:  MOVWF  77
054E:  RCALL  0452
....................     delay_ms(5);
0550:  MOVLW  05
0552:  MOVWF  70
0554:  RCALL  042C
0556:  INCF   6D,F
0558:  BRA    0544
....................    }
.................... 
.................... lcd_send_nibble(0x02);
055A:  MOVLW  02
055C:  MOVWF  77
055E:  RCALL  0452
.................... 
.................... for(i=0; i < sizeof(LCD_INIT_STRING); i++)
0560:  CLRF   6D
0562:  MOVF   6D,W
0564:  SUBLW  03
0566:  BNC   057A
....................    {
....................     lcd_send_byte(0, LCD_INIT_STRING[i]);
0568:  CLRF   03
056A:  MOVF   6D,W
056C:  RCALL  02DA
056E:  MOVWF  6E
0570:  CLRF   74
0572:  MOVWF  75
0574:  RCALL  04EA
....................    
....................     // If the R/W signal is not used, then
....................     // the busy bit can't be polled.  One of
....................     // the init commands takes longer than
....................     // the hard-coded delay of 50 us, so in
....................     // that case, lets just do a 5 ms delay
....................     // after all four of them.
....................     #ifndef USE_RW_PIN
0576:  INCF   6D,F
0578:  BRA    0562
....................     delay_ms(5);
....................     #endif
....................    }
057A:  GOTO   0A86 (RETURN)
.................... 
.................... }
.................... 
.................... //----------------------------
.................... 
.................... void lcd_gotoxy(int8 x, int8 y)
.................... {
.................... int8 address;
.................... 
.................... 
.................... switch(y)
057E:  MOVF   71,W
0580:  XORLW  01
0582:  BZ    0592
0584:  XORLW  03
0586:  BZ    0596
0588:  XORLW  01
058A:  BZ    059C
058C:  XORLW  07
058E:  BZ    05A2
0590:  BRA    05A8
....................   {
....................    case 1:
....................      address = LCD_LINE_1_ADDRESS;
0592:  CLRF   72
....................      break;
0594:  BRA    05AA
.................... 
....................    case 2:
....................      address = LCD_LINE_2_ADDRESS;
0596:  MOVLW  40
0598:  MOVWF  72
....................      break;
059A:  BRA    05AA
.................... 
....................    case 3:
....................      address = LCD_LINE_3_ADDRESS;
059C:  MOVLW  14
059E:  MOVWF  72
....................      break;
05A0:  BRA    05AA
.................... 
....................    case 4:
....................      address = LCD_LINE_4_ADDRESS;
05A2:  MOVLW  54
05A4:  MOVWF  72
....................      break;
05A6:  BRA    05AA
.................... 
....................    default:
....................      address = LCD_LINE_1_ADDRESS;
05A8:  CLRF   72
....................      break;
....................      
....................   }
.................... 
.................... address += x-1;
05AA:  MOVLW  01
05AC:  SUBWF  70,W
05AE:  ADDWF  72,F
.................... lcd_send_byte(0, 0x80 | address);
05B0:  MOVF   72,W
05B2:  IORLW  80
05B4:  MOVWF  73
05B6:  CLRF   74
05B8:  MOVWF  75
05BA:  RCALL  04EA
05BC:  RETURN 0
.................... }
.................... 
.................... //-----------------------------
.................... void lcd_putc(char c)
.................... {
....................  switch(c)
05BE:  MOVF   6F,W
05C0:  XORLW  0C
05C2:  BZ    05CE
05C4:  XORLW  06
05C6:  BZ    05E2
05C8:  XORLW  02
05CA:  BZ    05F0
05CC:  BRA    05FA
....................    {
....................     case '\f':
....................       lcd_send_byte(0,1);
05CE:  CLRF   74
05D0:  MOVLW  01
05D2:  MOVWF  75
05D4:  RCALL  04EA
....................       lcd_line = 1;
05D6:  MOVLW  01
05D8:  MOVWF  64
....................       delay_ms(2);
05DA:  MOVLW  02
05DC:  MOVWF  70
05DE:  RCALL  042C
....................       break;
05E0:  BRA    0604
....................    
....................     case '\n':
....................        lcd_gotoxy(1, ++lcd_line);
05E2:  INCF   64,F
05E4:  MOVLW  01
05E6:  MOVWF  70
05E8:  MOVFF  64,71
05EC:  RCALL  057E
....................        break;
05EE:  BRA    0604
....................    
....................     case '\b':
....................        lcd_send_byte(0,0x10);
05F0:  CLRF   74
05F2:  MOVLW  10
05F4:  MOVWF  75
05F6:  RCALL  04EA
....................        break;
05F8:  BRA    0604
....................    
....................     default:
....................        lcd_send_byte(1,c);
05FA:  MOVLW  01
05FC:  MOVWF  74
05FE:  MOVFF  6F,75
0602:  RCALL  04EA
....................        break;
....................    }
0604:  RETURN 0
.................... }
.................... 
.................... //------------------------------
.................... #ifdef USE_RW_PIN
.................... char lcd_getc(int8 x, int8 y)
.................... {
.................... char value;
.................... 
.................... lcd_gotoxy(x,y);
.................... 
.................... // Wait until busy flag is low.
.................... while(bit_test(lcd_read_byte(),7)); 
.................... 
.................... output_high(LCD_RS);
.................... value = lcd_read_byte();
.................... output_low(LCD_RS);
.................... 
.................... return(value);
.................... }
.................... #endif
.................... 
.................... 
....................  
.................... #define OUT1   PIN_C4 // if address 0 is 1 this pin will be ON, if address 0 is 0 this pin will be OFF
.................... 
.................... int16 hold_regs[] = {0x0001,0x0002,0x0003}; //registers
....................  
.................... int8 swap_bits(int8 c)
.................... {
....................    return ((c&1)?128:0)|((c&2)?64:0)|((c&4)?32:0)|((c&8)?16:0)|((c&16)?8:0)
....................           |((c&32)?4:0)|((c&64)?2:0)|((c&128)?1:0);
.................... }
.................... 
.................... void modbus_getdata(){
.................... 
....................       if((modbus_rx.address == MODBUS_ADDRESS))
*
07BE:  MOVF   1B,W
07C0:  SUBLW  05
07C2:  BTFSS  FD8.2
07C4:  BRA    095A
....................       {
....................       output_high(MODBUS_SERIAL_RX_ENABLE);
07C6:  BCF    F95.2
07C8:  BSF    F8C.2
....................       
....................          switch(modbus_rx.func)
07CA:  MOVF   1D,W
07CC:  XORLW  03
07CE:  BZ    07DA
07D0:  XORLW  05
07D2:  BZ    0830
07D4:  XORLW  16
07D6:  BZ    088E
07D8:  BRA    094A
....................          {
....................             case FUNC_READ_HOLDING_REGISTERS:
....................                if(modbus_rx.data[0] || modbus_rx.data[2] ||
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8)
07DA:  MOVF   1F,F
07DC:  BNZ   07F0
07DE:  MOVF   21,F
07E0:  BNZ   07F0
07E2:  MOVF   20,W
07E4:  SUBLW  07
07E6:  BNC   07F0
07E8:  MOVF   20,W
07EA:  ADDWF  22,W
07EC:  SUBLW  08
07EE:  BC    0802
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
07F0:  MOVLW  05
07F2:  MOVWF  6F
07F4:  CLRF   71
07F6:  MOVFF  1D,70
07FA:  MOVLW  02
07FC:  MOVWF  72
07FE:  RCALL  06FA
0800:  BRA    082E
....................                else
....................                {
....................                   if(modbus_rx.func == FUNC_READ_HOLDING_REGISTERS)
0802:  MOVF   1D,W
0804:  SUBLW  03
0806:  BNZ   082E
....................                      modbus_read_holding_registers_rsp(MODBUS_ADDRESS,(modbus_rx.data[3]*2),hold_regs+modbus_rx.data[1]);
0808:  BCF    FD8.0
080A:  RLCF   22,W
080C:  MOVWF  6F
080E:  BCF    FD8.0
0810:  RLCF   20,W
0812:  ADDLW  65
0814:  MOVWF  70
0816:  CLRF   71
0818:  BTFSC  FD8.0
081A:  INCF   71,F
081C:  MOVLW  05
081E:  MOVWF  72
0820:  MOVFF  6F,73
0824:  MOVFF  71,75
0828:  MOVFF  70,74
082C:  BRA    0712
....................                }
....................                break;
082E:  BRA    095A
.................... 
....................             case FUNC_WRITE_SINGLE_REGISTER:
....................                if(modbus_rx.data[0] || modbus_rx.data[1] >= 8)
0830:  MOVF   1F,F
0832:  BNZ   083A
0834:  MOVF   20,W
0836:  SUBLW  07
0838:  BC    084C
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
083A:  MOVLW  05
083C:  MOVWF  6F
083E:  CLRF   71
0840:  MOVFF  1D,70
0844:  MOVLW  02
0846:  MOVWF  72
0848:  RCALL  06FA
084A:  BRA    088C
....................                else
....................                {
....................                   hold_regs[modbus_rx.data[1]] = make16(modbus_rx.data[2],modbus_rx.data[3]);
084C:  BCF    FD8.0
084E:  RLCF   20,W
0850:  CLRF   03
0852:  ADDLW  65
0854:  MOVWF  FE9
0856:  MOVLW  00
0858:  ADDWFC 03,W
085A:  MOVWF  FEA
085C:  MOVFF  21,FEC
0860:  MOVF   FED,F
0862:  MOVFF  22,FEF
....................                   
....................                   modbus_write_single_register_rsp(MODBUS_ADDRESS,
....................                                make16(modbus_rx.data[0],modbus_rx.data[1]),
....................                                make16(modbus_rx.data[2],modbus_rx.data[3]));
0866:  MOVFF  1F,70
086A:  MOVFF  20,6F
086E:  MOVFF  21,72
0872:  MOVFF  22,71
0876:  MOVLW  05
0878:  MOVWF  73
087A:  MOVFF  1F,75
087E:  MOVFF  20,74
0882:  MOVFF  21,77
0886:  MOVFF  22,76
088A:  BRA    076E
....................                               
....................                }
....................                break;
088C:  BRA    095A
....................                
....................             case FUNC_WRITE_MULTIPLE_REGISTERS:
....................                if(modbus_rx.data[0] || modbus_rx.data[2] ||
....................                   modbus_rx.data[1] >= 8 || modbus_rx.data[3]+modbus_rx.data[1] > 8)
088E:  MOVF   1F,F
0890:  BNZ   08A4
0892:  MOVF   21,F
0894:  BNZ   08A4
0896:  MOVF   20,W
0898:  SUBLW  07
089A:  BNC   08A4
089C:  MOVF   20,W
089E:  ADDWF  22,W
08A0:  SUBLW  08
08A2:  BC    08B6
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_DATA_ADDRESS);
08A4:  MOVLW  05
08A6:  MOVWF  6F
08A8:  CLRF   71
08AA:  MOVFF  1D,70
08AE:  MOVLW  02
08B0:  MOVWF  72
08B2:  RCALL  06FA
08B4:  BRA    0948
....................                else
....................                {
....................                   int i,j;
....................  
....................                   for(i=0,j=5; i < modbus_rx.data[4]/2; ++i,j+=2)
08B6:  CLRF   6D
08B8:  MOVLW  05
08BA:  MOVWF  6E
08BC:  BCF    FD8.0
08BE:  RRCF   23,W
08C0:  SUBWF  6D,W
08C2:  BC    0922
....................                      hold_regs[i] = make16(modbus_rx.data[j],modbus_rx.data[j+1]);
08C4:  BCF    FD8.0
08C6:  RLCF   6D,W
08C8:  CLRF   03
08CA:  ADDLW  65
08CC:  MOVWF  01
08CE:  MOVLW  00
08D0:  ADDWFC 03,F
08D2:  MOVFF  01,6F
08D6:  MOVFF  03,70
08DA:  CLRF   03
08DC:  MOVF   6E,W
08DE:  ADDLW  1F
08E0:  MOVWF  FE9
08E2:  MOVLW  00
08E4:  ADDWFC 03,W
08E6:  MOVWF  FEA
08E8:  MOVFF  FEF,71
08EC:  MOVLW  01
08EE:  ADDWF  6E,W
08F0:  CLRF   03
08F2:  ADDLW  1F
08F4:  MOVWF  FE9
08F6:  MOVLW  00
08F8:  ADDWFC 03,W
08FA:  MOVWF  FEA
08FC:  MOVFF  FEF,72
0900:  MOVFF  71,74
0904:  MOVFF  72,73
0908:  MOVFF  70,FEA
090C:  MOVFF  01,FE9
0910:  MOVFF  71,FEC
0914:  MOVF   FED,F
0916:  MOVFF  72,FEF
091A:  INCF   6D,F
091C:  MOVLW  02
091E:  ADDWF  6E,F
0920:  BRA    08BC
....................  
....................                   modbus_write_multiple_registers_rsp(MODBUS_ADDRESS,
....................                                  make16(modbus_rx.data[0],modbus_rx.data[1]),
....................                                  make16(modbus_rx.data[2],modbus_rx.data[3]));
0922:  MOVFF  1F,70
0926:  MOVFF  20,6F
092A:  MOVFF  21,72
092E:  MOVFF  22,71
0932:  MOVLW  05
0934:  MOVWF  73
0936:  MOVFF  1F,75
093A:  MOVFF  20,74
093E:  MOVFF  21,77
0942:  MOVFF  22,76
0946:  BRA    0796
....................  
....................                }
....................                break;
0948:  BRA    095A
....................             default:    //We don't support the function, so return exception
....................                modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_FUNCTION);
094A:  MOVLW  05
094C:  MOVWF  6F
094E:  CLRF   71
0950:  MOVFF  1D,70
0954:  MOVLW  01
0956:  MOVWF  72
0958:  RCALL  06FA
....................          }
....................       }
....................       output_low(MODBUS_SERIAL_RX_ENABLE); 
095A:  BCF    F95.2
095C:  BCF    F8C.2
095E:  GOTO   0B02 (RETURN)
....................   }
.................... 
.................... void main()
*
0A26:  CLRF   FF8
0A28:  BCF    FD0.7
0A2A:  BSF    07.7
0A2C:  MOVLW  70
0A2E:  MOVWF  FD3
0A30:  CLRF   F9B
0A32:  MOVF   FD3,W
0A34:  BCF    1A.0
0A36:  CLRF   5F
0A38:  BCF    FCD.0
0A3A:  MOVLW  B5
0A3C:  MOVWF  FCD
0A3E:  CLRF   FCF
0A40:  CLRF   FCE
0A42:  NOP   
0A44:  BCF    F9E.0
0A46:  BSF    F9D.0
0A48:  CLRF   60
0A4A:  BCF    FB8.3
0A4C:  MOVLW  0C
0A4E:  MOVWF  FAF
0A50:  MOVLW  E2
0A52:  MOVWF  FAC
0A54:  MOVLW  D0
0A56:  MOVWF  FAB
0A58:  NOP   
0A5A:  NOP   
0A5C:  BCF    1A.1
0A5E:  CLRF   61
0A60:  CLRF   6C
0A62:  CLRF   6B
0A64:  MOVF   FC1,W
0A66:  ANDLW  C0
0A68:  IORLW  0F
0A6A:  MOVWF  FC1
0A6C:  MOVLW  07
0A6E:  MOVWF  FB4
0A70:  MOVLW  01
0A72:  MOVWF  65
0A74:  CLRF   66
0A76:  MOVLW  02
0A78:  MOVWF  67
0A7A:  CLRF   68
0A7C:  MOVLW  03
0A7E:  MOVWF  69
0A80:  CLRF   6A
.................... {
....................    
....................    modbus_init();
0A82:  BRA    0420
....................    lcd_init();
0A84:  BRA    052C
....................    delay_ms(100);
0A86:  MOVLW  64
0A88:  MOVWF  70
0A8A:  RCALL  042C
....................    
....................    lcd_gotoxy(1,1);
0A8C:  MOVLW  01
0A8E:  MOVWF  70
0A90:  MOVWF  71
0A92:  RCALL  057E
....................    lcd_putc("System Started!");
0A94:  MOVLW  F2
0A96:  MOVWF  FF6
0A98:  MOVLW  03
0A9A:  MOVWF  FF7
0A9C:  BRA    0606
....................  
....................    while(TRUE)
....................    {
....................    
....................    lcd_gotoxy(1,2);
0A9E:  MOVLW  01
0AA0:  MOVWF  70
0AA2:  MOVLW  02
0AA4:  MOVWF  71
0AA6:  RCALL  057E
....................    printf(lcd_putc,"%4LX",hold_regs[0]); //2nd line of LCD shows adress 0 value (register 0)
0AA8:  MOVFF  66,6D
0AAC:  MOVLW  37
0AAE:  MOVWF  6E
0AB0:  RCALL  0628
0AB2:  MOVFF  65,6D
0AB6:  MOVLW  37
0AB8:  MOVWF  6E
0ABA:  RCALL  0628
....................    
....................    lcd_gotoxy(1,3);
0ABC:  MOVLW  01
0ABE:  MOVWF  70
0AC0:  MOVLW  03
0AC2:  MOVWF  71
0AC4:  RCALL  057E
....................    printf(lcd_putc,"%4LX",hold_regs[1]); //3th line of LCD shows adress 1 value (register 1)
0AC6:  MOVFF  68,6D
0ACA:  MOVLW  37
0ACC:  MOVWF  6E
0ACE:  RCALL  0628
0AD0:  MOVFF  67,6D
0AD4:  MOVLW  37
0AD6:  MOVWF  6E
0AD8:  RCALL  0628
....................    
....................    lcd_gotoxy(1,4);
0ADA:  MOVLW  01
0ADC:  MOVWF  70
0ADE:  MOVLW  04
0AE0:  MOVWF  71
0AE2:  RCALL  057E
....................    printf(lcd_putc,"%4LX",hold_regs[2]); //4th line of LCD shows adress 2 value (register 2)
0AE4:  MOVFF  6A,6D
0AE8:  MOVLW  37
0AEA:  MOVWF  6E
0AEC:  RCALL  0628
0AEE:  MOVFF  69,6D
0AF2:  MOVLW  37
0AF4:  MOVWF  6E
0AF6:  RCALL  0628
....................    
....................    delay_us(50);
0AF8:  MOVLW  21
0AFA:  MOVWF  00
0AFC:  DECFSZ 00,F
0AFE:  BRA    0AFC
....................       
....................    modbus_getdata();
0B00:  BRA    07BE
....................    
....................       
....................    while(!modbus_kbhit()){ 
0B02:  BRA    0A02
0B04:  MOVF   01,F
0B06:  BNZ   0B22
....................    
....................    if(hold_regs[0]==1){
0B08:  DECFSZ 65,W
0B0A:  BRA    0B14
0B0C:  MOVF   66,F
0B0E:  BNZ   0B14
....................       output_high(OUT1);
0B10:  BCF    F94.4
0B12:  BSF    F8B.4
....................    }
....................    
....................    if(hold_regs[0]==0){
0B14:  MOVF   65,F
0B16:  BNZ   0B20
0B18:  MOVF   66,F
0B1A:  BNZ   0B20
....................       output_low(OUT1);
0B1C:  BCF    F94.4
0B1E:  BCF    F8B.4
....................    }
0B20:  BRA    0B02
....................    
....................    }
0B22:  BRA    0A9E
....................  
....................     
.................... }
.................... 
.................... }
.................... 
0B24:  SLEEP 

Configuration Fuses:
   Word  1: C800   INTRC_IO FCMEN IESO
   Word  2: 1E1E   PUT BROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
